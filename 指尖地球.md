# 指尖地球技术实现

> 胡姐这里我大概写一下实现效果，你没下Markdown阅读器，所以我直接给你导出pdf，你需要的直接复制，这样子刚好也不会让你的格式乱

## 实现效果

本系统实现了一个基于STM32的非洲大陆早教立体拼图交互装置，核心功能包括：

1. **触控开关控制** 通过电容式触控模块实现整体系统电源控制，短按启动/关闭设备。
2. **拼图状态检测** 每个拼图模块配备双接触式传感器，当拼图块正确嵌入时，两个传感器同时被触发，系统通过GPIO电平变化进行实时检测。
3. **多模态反馈机制**
   - **灯光反馈**：正确拼接后，对应区域的RGB LED亮起灯光
   - **语音播报**：通过MP3解码模块播放预存的该地区人文地理语音介绍（如："撒哈拉沙漠：位于非洲北部，世界最大的热带沙漠，气候终年高温少雨。植被稀疏，生活着骆驼、蜥蜴、蛇、鼠类等，它们多在夜间活动以躲避白天的高温..."）
4. **错误处理机制**
   - 误放置检测：单传感器触发持续超过2秒未匹配则触发错误提示
   - 防抖设计：20ms消抖处理避免接触不良导致的误判

## 环境搭建

> 因为交互装置整体代码量较小，所以这里直接使用标准库进行开发

### 一、硬件环境搭建

#### 1. 核心部件清单

| 部件名称        | 型号/参数                 | 数量 | 连接方式         |
| --------------- | ------------------------- | ---- | ---------------- |
| 主控芯片        | STM32F103C8T6 (Cortex-M3) | 1    | 核心板直插       |
| 触控模块        | TTP223电容式触摸芯片      | 1    | 电源直插         |
| 双触点传感器    | 磁吸开关                  | 12   | PA0-PA7,PB0-PB11 |
| 电源管理模块    | 5V3000mA锂电池            | 1    | 锂电池输入       |
| 语音模块JR60001 | （UART控制）              | 1    | PA9(TX)/PA10(RX) |

### 二、软件开发环境

- **IDE**: Keil uVision V5.29
- **编译器**: ARMCC V5.06
- **调试器**: ST-Link V2

![image-20250511234045199](https://gitee.com/jason_pei/typora-bed/raw/master/image/202505112340288.png)

## 实现流程

### 一、系统架构设计

![](https://gitee.com/jason_pei/typora-bed/raw/master/image/202505112329810.png)

### 硬件组成

| 模块       | 实现方式                | 关键配置                          |
| ---------- | ----------------------- | --------------------------------- |
| 主控芯片   | STM32F103C8T6           | GPIO模式配置为下拉输入，50MHz速度 |
| 接触传感器 | 磁吸触点开关x2/地图块   | 双触点串联设计，防止误触发        |
| 反馈装置   | LED+限流电阻            | 每组拼图对应1个LED，GPIO直接驱动  |
| 语音播报   | 无源蜂鸣器或简单MP3模块 | PWM驱动蜂鸣器或串口控制语音芯片   |

### 二、核心实现逻辑

#### 1. 双触点检测机制

```
if (curr1 && curr2) {  // 同时检测两个触点
    if (!(上次双高) && 维持时间>20ms) {
        判定为正确拼装
    }
}
```

- **防误触设计**：必须两个触点同时导通才视为有效
- **软件消抖**：20ms状态维持检测（代码中DEBOUNCE_TIME）
- **硬件消抖：**因为场地资源有限，没有风枪等设备焊接贴片电阻电容，所以并未添加硬件消抖

#### 2. GPIO资源分配

| 拼图编号 | 端口 | 引脚1 | 引脚2 |
| -------- | ---- | ----- | ----- |
| 1        | PA   | PA0   | PA1   |
| 2        | PA   | PA2   | PA3   |
| 3        | PA   | PA4   | PA5   |
| 4        | PA   | PA6   | PA7   |
| 5        | PB   | PB1   | PB2   |
| 6        | PB   | PB10  | PB11  |

#### 3. 状态检测流程

```
sequenceDiagram
    主循环->>传感器扫描: 每10ms轮询
    传感器扫描->>触点1: 读取PA0状态
    传感器扫描->>触点2: 读取PA1状态
    触点1/2-->>传感器扫描: 返回电平值
    传感器扫描->>逻辑判断: 双高电平持续20ms?
    逻辑判断-->>主程序: 返回拼图ID和状态
    主程序->>LED控制: 点亮对应PC0
    主程序->>语音输出: 触发播放
```

### 三、关键技术实现

#### 1. 高效扫描算法

```
Cfor(int i=0; i<MAX_PUZZLES; i++) {
    // 批量读取整个端口状态
    uint16_t port_val = GPIO_ReadInputData(puzzles[i].GPIOx);
    curr1 = (port_val & puzzles[i].pin1) ? 1 : 0;
    curr2 = (port_val & puzzles[i].pin2) ? 1 : 0;
    // 后续判断逻辑...
}
```

- **优化技巧**：单次读取整个端口寄存器，减少IO操作次数
- **时间复杂度**：O(n)线性扫描，6组拼图仅需6次循环

#### 2. 状态缓存机制

```
Ctypedef struct {
    uint8_t last_state1;   // 保存前次状态
    uint8_t last_state2;   
    uint32_t edge_time;     // 状态跳变时间戳
} PuzzleSensor;
```

- 实现功能：
  - 记录历史状态用于边缘检测
  - 时间戳实现精准消抖计时
  - 防止重复触发（edge_time清零机制）

### 四、异常处理设计

#### 1. 触点故障检测

```
C// 在初始化时增加端口自检
void Hardware_Check() {
    for(int i=0; i<MAX_PUZZLES; i++) {
        if(GPIO_ReadInputDataBit(puzzles[i].GPIOx, puzzles[i].pin1) == 1 ||
           GPIO_ReadInputDataBit(puzzles[i].GPIOx, puzzles[i].pin2) == 1) {
            // 上电时应为低电平，否则提示触点故障
            Error_Handler(); 
        }
    }
}
```

#### 2. 冲突解决策略

- **优先级设计**：多个拼图同时正确时，按ID顺序处理
- **状态锁定**：拼图正确后锁定该组检测，直到状态解除
- **超时重置**：30秒无操作自动复位所有状态

此方案分析聚焦实际实现的GPIO双触点检测核心功能，删除冗余模块描述，更符合当前代码实现复杂度。建议在文档中配合引脚分配表、状态转移图等实际开发中使用的设计元素。